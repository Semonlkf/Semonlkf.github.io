<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Pandas教程</title>
    <url>/2023/08/15/Pandas%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Tutorials</category>
      </categories>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/08/12/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a class="link"   href="https://hexo.io/" >Hexo <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>! This is your very first post. Check <a class="link"   href="https://hexo.io/docs/" >documentation <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> for more info. If you get any problems when using Hexo, you can find the answer in <a class="link"   href="https://hexo.io/docs/troubleshooting.html" >troubleshooting <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> or you can ask me on <a class="link"   href="https://github.com/hexojs/hexo/issues" >GitHub <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/writing.html" >Writing <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/server.html" >Server <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/generating.html" >Generating <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/one-command-deployment.html" >Deployment <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
  </entry>
  <entry>
    <title>RT系列</title>
    <url>/2024/04/11/RT%E7%B3%BB%E5%88%97/</url>
    <content><![CDATA[<h2 id="RT-1"><a href="#RT-1" class="headerlink" title="RT-1"></a>RT-1</h2><h3 id="简单概括"><a href="#简单概括" class="headerlink" title="简单概括"></a>简单概括</h3><p>RT-1模型在包含130k个episode的大型真实机器人数据集上进行训练，该数据集涵盖了700 多项任务，使用Everyday Robots (EDR)的13台机器人在17个月内收集而成。数据集中展示的一组高级技能包括拾取和放置物品、打开和关闭抽屉、将物品放入和取出抽屉、将细长的物品直立放置、敲倒物体、拉出餐巾纸和打开罐子。</p>
<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>指令+图片</p>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>3HZ刷新率的动作集合</p>
<h3 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h3><p>我们使用了13个EDR机器人操纵器，每个都带有7个自由度的手臂、一个2指夹持器和一个移动底座，在17个月内收集了13万数据集。我们使用人类通过远程操作提供的演示，并用机器人刚刚执行的指令的文本描述对每一集进行注释。 数据集中表示的一组高级技能包括拾取和放置物品、 打开和关闭抽屉、将物品放入和取出抽屉、将细长的物品直立放置、将物体打翻、拉餐巾和打开罐子。生成的数据集包括130k+集，涵盖使用许多不同对象的700多个任务。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">The two main challenges lie in assembling the right dataset and designing the right model. While data collection and curation is often the &quot;unsung hero&quot; of many large-scale machine learning projects (Radford et al., 2021; Ramesh et al., 2021), this is especially true in robotics, where datasets are often robot-specific and gathered manually (Dasari et al., 2019; Ebert et al., 2021).</span><br></pre></td></tr></table></figure></div>

<p>两个主要挑战在于组装正确的数据集和设计正确的模型。虽然数据收集和管理通常是许多大规模机器学习项目的“非替代英雄”（Radford 等人，2021；Ramesh 等人，2021），但在机器人技术中尤其如此，其中数据集通常是特定于机器人的并手动收集的（Dasari 等人，2019；Ebert 等人，2021）。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Our goal is to build a system that exhibits high performance, generalization to new tasks, and robustness to distractors and backgrounds. We therefore aim to collect a large, diverse dataset of robot trajectories that includes multiple tasks, objects and environments. Our primary dataset consists of∼130k robot demonstrations, collected with a fleet of 13 robots over the course of 17 months. We conducted this large-scale data collection in a series of office kitchen segments, which we refer to asrobot classrooms, shown in Fig. 2. More details on data collection are in Appendix C.2.</span><br></pre></td></tr></table></figure></div>

<p>我们的目标是构建一个表现出高性能、泛化到新任务以及对干扰物和背景的鲁棒性的系统。因此，我们的目标是收集一个大型、多样化的机器人轨迹数据集，其中包括多个任务、对象和环境。我们的主要数据集由∼130k机器人演示组成，在17个月的时间里用13个机器人车队收集。我们在一系列办公室厨房段进行了这种大规模的数据收集，我们称之为机器人教室，如图2所示。关于数据收集的更多细节见附录C.2。</p>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>RT-1建立在一个转换器架构(transformer)上, 该架构从机器人的相机中获取图像的简短历史以及以自然语言表达的任务描述作为输入,并直接输出标记化的动作。<br>RT-1的体系结构类似于针对具有因果掩蔽的标准分类交叉熵目标训练的当代仅解码器序列模型。其主要功能包括:图像标记化、动作标记化和标记压缩,如下所述。<br><strong>图像标记化</strong>:我们通过在ImageNet上预训练的EfficientNet-B3模型传递图像,然后将生成的9x9x512空间特征图扁平化为81个标记。图像分词器以自然语言任务指令条件,并使用初始化为身份的FiLM层在早期提取与任务相关的图像特征。<br><strong>动作标记化</strong>:机器人的动作维度是手臂运动的7个变量(x、y. z. 滚动、俯仰、偏航、夹具打开)，3个基座运动变量(x、 y.偏航)， 以及一个额外的离散变量来切换在三种模式之间:控制臂、控制基地或终止剧集。每个动作维度被离散化为256个bin.<br><strong>令牌压缩</strong>:该模型自适应地选择图像令牌的软组合,这些组合可以根据它们对使用元素注意模块TokenL earner进行学习的影响进行压缩，从而使推理速度提高2.4倍以上。</p>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/Semonlkf/image@main/img/rt1.png"
                     
                ></p>
<h2 id="RT-2"><a href="#RT-2" class="headerlink" title="RT-2"></a>RT-2</h2><h3 id="简单概括-1"><a href="#简单概括-1" class="headerlink" title="简单概括"></a>简单概括</h3><p>据了解，谷歌DeepMind这项成果由54位研究员合作产出，前前后后拉扯7个月。<br>视觉-语言模型(vlm)在网络规模的数据集上进行训练,使这些系统在识别视觉或语言模式和跨不同语言操作方面表现得非常好。但是对于机器人来说，要达到类似的能力水平,<br>他们需要收集机器人在每个对象、环境、任务和情况下的第一手数据。<br>本文提出robot Transformer 2 (RT-2)，一种新的视觉-语言动作(VLA)模型，从网络和机器人数据中学习,并将这种知识转换为用于机器人控制的通用指令，同时保留网络规模<br>的能力。<br>RT-2显显出改进的泛化能力以及语义和视觉理解，超出了它接触的机器人数据。这包括解释新命令并通过执行基本推理(例如关于对象类别或高级描述的推理)来响应用户命令。</p>
<h3 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h3><p>图片+文本</p>
<h3 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h3><p>动作（编码为文本）<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/Semonlkf/image@main/img/rt2.png"
                     
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/Semonlkf/image@main/img/rt3.png"
                     
                ></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 continue</span><br></pre></td></tr></table></figure></div>

<h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><ul>
<li>backbone 是50亿和550亿的PaLl-X、30 亿的PaLl以及120亿的PaLM-E。</li>
<li>为了提升大模型本身的能力,把思维链、向量数据库和无梯度架构(no-gradient-architectures) 都用上了。</li>
<li>将原本非常具体的机器人动作数据，转变成文本token。 视觉-语言-行动” (VLA)模型最大的模型.55B参数RT-2-PaLI-X-55B模型，可以运行在1- 3hz的频率。该模型的较小版本包含5B个参数，可以以大约5赫兹的频率运行。</li>
<li>模型微调这里还没太懂<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/Semonlkf/image@main/img/rt5.png"
                     
                ></li>
</ul>
<h3 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h3><p>在一些任务上，有了很大的进步。<br>但泛化性一般，抓东西效果可能不是很好<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/Semonlkf/image@main/img/20240319153415.png"
                     
                ></p>
<h2 id="RT-H"><a href="#RT-H" class="headerlink" title="RT-H"></a>RT-H</h2><h3 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h3><ul>
<li>讨论了由于任务的语义多样性，直接从高层任务映射到机器人动作的限制，提出使用语言描述低层动作（语言动作）作为中间步骤来增强任务间的数据共享并允许人为纠正。</li>
<li><strong>核心思想：</strong> RT-H引入了一个使用语言动作的行为层级，其中机器人首先基于给定的任务和观察学习预测语言动作，然后在这些语言动作的条件下预测动作。这种方法利用了语言的结构来更好地理解和执行任务，使策略更加健壮和灵活，并从人提供的语言动作校正中受益。</li>
</ul>
<h3 id="数据集-1"><a href="#数据集-1" class="headerlink" title="数据集"></a>数据集</h3><p>应该还是RT-2的数据集，加入Diverse数据集</p>
<h3 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h3><p>自然语言的高层任务描述和场景的视觉观察。</p>
<h3 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h3><p>两层：<br>低级的动作语言<br>基于这些语言动作和原始输入的机器人动作</p>
]]></content>
      <categories>
        <category>Emboied AI</category>
      </categories>
  </entry>
  <entry>
    <title>动态规划（1）</title>
    <url>/2024/04/12/%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>这部分是规范学习动态规划算法的一些刷题记录。可以去看acwing的回放课。</p>
<h1 id="数字三角形模型"><a href="#数字三角形模型" class="headerlink" title="数字三角形模型"></a>数字三角形模型</h1><p>从集合角度来考虑dp问题<br>dp的两个部分</p>
<h3 id="状态表示"><a href="#状态表示" class="headerlink" title="状态表示"></a>状态表示</h3><p>f[i,j]<br>状态表示的两个问题：<br>集合：用一个数来表示一类东西<br>属性：集合的某一个属性 。MIN&#x2F;MAX&#x2F;数量<br>以1015摘花生为例：<br>![[算法 2024-04-08 13.24.27.excalidraw]]<br>算法中的坐标表示<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/Semonlkf/image@main/img/20240412145209.png"
                      alt="image.png"
                ></p>
<p>以1027数花生为例。<br><strong>状态表示</strong><br>集合：从(1,1)走到(i,j)的路线<br>属性：最大值<br>f(n,m)的花生最大值</p>
<h2 id="状态计算"><a href="#状态计算" class="headerlink" title="状态计算"></a><strong>状态计算</strong></h2><p>对应着集合的划分<br>![[算法 2024-04-08 13.28.22.excalidraw]]<br>(1,1)-&gt; (i-1,j)-&gt;(i,j)</p>
<p>f[i,j]&#x3D;max(f[i-1,j]+w[ij],f[i,j-1]+w[ij])</p>
<h2 id="acwing-1015-摘花生"><a href="#acwing-1015-摘花生" class="headerlink" title="acwing_1015 摘花生"></a>acwing_1015 摘花生</h2><p><a class="link"   href="https://www.acwing.com/file_system/file/content/whole/index/content/4183962/" >https://www.acwing.com/file_system/file/content/whole/index/content/4183962/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>题解：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> w[N][N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                cin&gt;&gt;w[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                f[i][j]=<span class="built_in">max</span>(f[i<span class="number">-1</span>][j],f[i][j<span class="number">-1</span>])+w[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;f[n][m]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="方格取数"><a href="#方格取数" class="headerlink" title="方格取数"></a>方格取数</h2><h1 id="NOIP2000-提高组-方格取数"><a href="#NOIP2000-提高组-方格取数" class="headerlink" title="[NOIP2000 提高组] 方格取数"></a>[NOIP2000 提高组] 方格取数</h1><h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>NOIP 2000 提高组 T4</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>设有 $N \times N$ 的方格图 $(N \le 9)$，我们将其中的某些方格中填入正整数，而其他的方格中则放入数字 $0$。如下图所示（见样例）:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.luogu.com.cn/upload/image_hosting/0bpummja.png"
                     
                ></p>
<p>某人从图的左上角的 $A$ 点出发，可以向下行走，也可以向右走，直到到达右下角的 $B$ 点。在走过的路上，他可以取走方格中的数（取走后的方格中将变为数字 $0$）。<br>此人从 $A$ 点到 $B$ 点共走两次，试找出 $2$ 条这样的路径，使得取得的数之和为最大。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入的第一行为一个整数 $N$（表示 $N \times N$ 的方格图），接下来的每行有三个整数，前两个表示位置，第三个数为该位置上所放的数。一行单独的 $0$ 表示输入结束。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>只需输出一个整数，表示 $2$ 条路径上取得的最大的和。</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">8</span><br><span class="line">2 3 13</span><br><span class="line">2 6  6</span><br><span class="line">3 5  7</span><br><span class="line">4 4 14</span><br><span class="line">5 2 21</span><br><span class="line">5 6  4</span><br><span class="line">6 3 15</span><br><span class="line">7 2 14</span><br><span class="line">0 0  0</span><br></pre></td></tr></table></figure></div>

<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">67</span><br></pre></td></tr></table></figure></div>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>数据范围：$1\le N\le 9$。<br>题解：<br>思路：走两次<br>f[i1,i2,j1,j2]表示所有从(1,1),(1,1)分别走到(i1,j1),(i2,j2)的路径的最大值<br>如何处理“同一个格子不能被重复选择”<br>只有在i1+j1&#x3D;i2+j2时，两条路径的格子才可能重合<br>优化状态<br>f[k,i1,i2]<br>k&#x3D;i1+j1&#x3D;i2+j2<br>![[算法 2024-04-11 19.57.46.excalidraw]]</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">11</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span> w[N][N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> f[<span class="number">2</span>*N][N][N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(flag)&#123;</span><br><span class="line">        <span class="type">int</span> i,j,k;</span><br><span class="line">        cin &gt;&gt;i&gt;&gt;j&gt;&gt;k;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">0</span>&amp;&amp;j==<span class="number">0</span>&amp;&amp;k==<span class="number">0</span>) flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            w[i][j]=k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">2</span>;k&lt;=n+n;k++)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i1=<span class="number">1</span>;i1&lt;=n;i1++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i2=<span class="number">1</span>;i2&lt;=n;i2++)&#123;</span><br><span class="line">          <span class="type">int</span> j1=k-i1,j2=k-i2;</span><br><span class="line">            <span class="keyword">if</span> (j1&gt;=<span class="number">1</span> &amp;&amp; j1&lt;=n &amp;&amp; j2&gt;=<span class="number">1</span> &amp;&amp; j2&lt;=n)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> temp = w[i1][j1];</span><br><span class="line">                <span class="keyword">if</span>(i1 != i2) temp+=w[i2][j2];</span><br><span class="line">                <span class="type">int</span> &amp;x = f[k][i1][i2];</span><br><span class="line">                x=<span class="built_in">max</span>(x,f[k<span class="number">-1</span>][i1<span class="number">-1</span>][i2<span class="number">-1</span>]+temp);</span><br><span class="line">                x=<span class="built_in">max</span>(x,f[k<span class="number">-1</span>][i1<span class="number">-1</span>][i2]+temp);</span><br><span class="line">                x=<span class="built_in">max</span>(x,f[k<span class="number">-1</span>][i1][i2<span class="number">-1</span>]+temp);</span><br><span class="line">                x=<span class="built_in">max</span>(x,f[k<span class="number">-1</span>][i1][i2]+temp);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[n+n][n][n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<h1 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h1><h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><p>题目描述：N个物品 容量为V的背包 每一个物品有两个属性，体积vi,价值wi<br>每件物品只能用一次<br>总体积&lt;&#x3D;V,挑出来的最大价值</p>
<h3 id="p1048-采药"><a href="#p1048-采药" class="headerlink" title="p1048 采药"></a>p1048 采药</h3><p>[<a class="link"   href="https://www.luogu.com.cn/problem/P1048]" >https://www.luogu.com.cn/problem/P1048] <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>![[算法 2024-04-12 15.10.58.excalidraw]]<br>$$f[i,j]&#x3D;max(f[i-1,j],f[i-1,j-vi]+wi)$$<br>初步题解</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line"><span class="type">int</span> m;</span><br><span class="line"><span class="type">int</span> w[N],v[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; t &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        cin &gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=t;j++)&#123;</span><br><span class="line">            f[i][j]=f[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">if</span>(j&gt;=v[i]) f[i][j]=<span class="built_in">max</span>(f[i][j],f[i<span class="number">-1</span>][j-v[i]]+w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[m][t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<blockquote>
<p>不要在初始行加一些奇怪的注释，会发生一些奇怪的问题</p>
</blockquote>
<h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><p>每个物品没有限制</p>
<h2 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h2><p>每个物品个数不一样，个数有si个</p>
<h2 id="分组背包问题"><a href="#分组背包问题" class="headerlink" title="分组背包问题"></a>分组背包问题</h2>]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
  </entry>
  <entry>
    <title>异构transformer</title>
    <url>/2024/04/12/%E5%BC%82%E6%9E%84transformer/</url>
    <content><![CDATA[<p>组会分享</p>
<h2 id="Transformer的不足"><a href="#Transformer的不足" class="headerlink" title="Transformer的不足"></a>Transformer的不足</h2><ol>
<li>位置编码精度问题</li>
</ol>
<ul>
<li>多头注意力机制天然不区分位置信息</li>
<li>简单的正弦函数不能很好的区分复杂的位置信息</li>
</ul>
<ol start="2">
<li>Attention计算复杂性问题</li>
</ol>
<ul>
<li>复杂度仍然是O(n^2)</li>
<li>训练推理阶段，显存及参数更新开销大</li>
<li>天然的多头并行化框架效果受限制于显存</li>
</ul>
<ol start="3">
<li>多模态适应性问题</li>
</ol>
<ul>
<li>图片需要额外训练</li>
</ul>
<h2 id="LLaMA"><a href="#LLaMA" class="headerlink" title="LLaMA"></a>LLaMA</h2><p>位置编码：使用旋转位置编码RoPE,加入对相对位置信息的关注<br>归一化方法：引入Pre-Norm方法，使用RMS Norm<br>激活函数：引入Swiglu</p>
<h2 id="旋转位置编码：RoPE"><a href="#旋转位置编码：RoPE" class="headerlink" title="旋转位置编码：RoPE"></a>旋转位置编码：RoPE</h2><p>原始位置编码</p>
<ul>
<li>固定式</li>
<li>学习是：将位置编码作为可训练参数，随训练过程更新<br>相对位置编码<br>Transformers-XL提出一种表示相对位置信息的编码<br>旋转位置编码：RoPE<br>RoFormer:相对位置和绝对位置均有贡献<br>复数域可以同时表示旋转和平移量个操作<br>原理<br>两个向量的内积可以看做两个复数乘积的实数部分<br>$$&lt;q_m,k_n&gt;&#x3D;Re[q]$$<br>如果我们将两个向量分别乘以引入绝对位置信息<br>发现内积仅依赖于相对位置信息<br>实现“推导在复数域，实际计算在实数域上</li>
</ul>
<h2 id="归一化方法：Pre-Norm"><a href="#归一化方法：Pre-Norm" class="headerlink" title="归一化方法：Pre-Norm"></a>归一化方法：Pre-Norm</h2><p>动机：将Layer Norm提前到Attention层之前<br>Post-Norm缺陷：<br>Layer Norm虽然防止了方差的累计，但增加了梯度回传的难度<br>Layer Norm中，越深层的梯度反而越打，越前的反而越小<br>这使得Transformer依赖warm-up,难以训练</p>
<h2 id="Attention方法的数种优化"><a href="#Attention方法的数种优化" class="headerlink" title="Attention方法的数种优化"></a>Attention方法的数种优化</h2><h3 id="稀疏Attention"><a href="#稀疏Attention" class="headerlink" title="稀疏Attention"></a>稀疏Attention</h3><p>膨胀自注意力<br>局部自注意力<br>融合局部与膨胀自注意力：Openai</p>
<h3 id="Attention的线性化尝试"><a href="#Attention的线性化尝试" class="headerlink" title="Attention的线性化尝试"></a>Attention的线性化尝试</h3><p>Attention计算复杂度分析<br>去除Softmax尝试<br>可以输用基于和函数的方法，将q,k中每个元素使用和函数，使其大于0<br>LinFormer:利用Attention矩阵的低秩性质<br>发现$softmax(QK^T)$是低质的<br>使用两个m*\k的矩阵E,F分别对K,V进行头型，降低<br>Att(QKV)&#x3D;softmax(Q(EK)^T)FV<br>这样，Q(EK)^T就是一个n*k的矩阵<br>PerFormer:构造巧妙地sim映射</p>
<h2 id="Spike-driven-Transformer"><a href="#Spike-driven-Transformer" class="headerlink" title="Spike-driven Transformer"></a>Spike-driven Transformer</h2><p>脉冲神经网路SNNs</p>
]]></content>
      <categories>
        <category>组会</category>
      </categories>
  </entry>
</search>
